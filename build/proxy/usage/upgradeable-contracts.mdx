---
title: Creating Upgradeable Proxy Contracts
description: "Build proxy contracts that can evolve and be upgraded over time"
---

Upgradeable proxy contracts allow you to fix bugs, add features, and evolve your application after deployment. They're more complex than basic contracts, so only use them when you actually need upgrade functionality.

<Warning>
  **Use upgradeable contracts sparingly**. They add complexity, potential security risks, and higher gas costs. Most applications work fine with basic, immutable contracts.
</Warning>

## When You Need Upgradeable Contracts

### Good Reasons to Use Upgradeability

**Bug fixes**: Critical security issues that need immediate fixes
```solidity
// V1: Bug in calculation
function calculateReward(uint256 amount) public pure returns (uint256) {
    return amount * 1.5; // Wrong: this truncates decimals
}

// V2: Fixed calculation  
function calculateReward(uint256 amount) public pure returns (uint256) {
    return (amount * 15) / 10; // Correct: preserves decimals
}
```

**Regulatory compliance**: Legal requirements that change over time
```solidity
// V1: No KYC required
function processTransaction(uint256 amount) external {
    // Process immediately
}

// V2: KYC requirement added
function processTransaction(uint256 amount) external {
    require(kycVerified[msg.sender], "KYC required");
    // Process transaction
}
```

**Protocol integrations**: Adding support for new DeFi protocols
```solidity
// V1: Only supports Uniswap
contract DeFiProxy is TacProxyV1Upgradeable {
    function swap() external {
        uniswapRouter.swap(/*...*/);
    }
}

// V2: Adds SushiSwap support
contract DeFiProxy is TacProxyV1Upgradeable {
    enum Protocol { UNISWAP, SUSHISWAP }
    
    function swap(Protocol protocol) external {
        if (protocol == Protocol.UNISWAP) {
            uniswapRouter.swap(/*...*/);
        } else {
            sushiswapRouter.swap(/*...*/);
        }
    }
}
```

### Bad Reasons to Use Upgradeability

❌ **"Just in case we need to change something"** - Adds complexity for no clear benefit
❌ **Adding new features** - Deploy new contracts instead
❌ **Gas optimizations** - Usually not worth the upgrade complexity
❌ **Changing business logic** - Often better to migrate to a new system

## Basic Upgradeable Structure

Upgradeable contracts use OpenZeppelin's UUPS (Universal Upgradeable Proxy Standard) pattern:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.28;

import { Initializable } from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import { UUPSUpgradeable } from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";
import { OwnableUpgradeable } from "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
import { TacProxyV1Upgradeable } from "@tonappchain/evm-ccl/contracts/proxies/TacProxyV1Upgradeable.sol";
import { TacHeaderV1 } from "@tonappchain/evm-ccl/contracts/core/Structs.sol";

contract MyUpgradeableProxy is
    Initializable,
    OwnableUpgradeable,
    UUPSUpgradeable,
    TacProxyV1Upgradeable
{
    // Your state variables go here
    mapping(string => uint256) public userBalances;
    uint256 public totalProcessed;
    
    /// @custom:oz-upgrades-unsafe-allow constructor
    constructor() {
        _disableInitializers();
    }

    function initialize(address owner, address crossChainLayer) 
        public 
        initializer 
    {
        __UUPSUpgradeable_init();
        __Ownable_init(owner);
        __TacProxyV1Upgradeable_init(crossChainLayer);
        
        // Initialize your contract state
        totalProcessed = 0;
    }

    function _authorizeUpgrade(address newImplementation) 
        internal 
        override 
        onlyOwner 
    {}

    // Your proxy functions go here
    function processRequest(bytes calldata tacHeader, bytes calldata arguments)
        external
        _onlyCrossChainLayer
    {
        TacHeaderV1 memory header = _decodeTacHeader(tacHeader);
        uint256 amount = abi.decode(arguments, (uint256));
        
        userBalances[header.tvmCaller] += amount;
        totalProcessed += amount;
        
        emit RequestProcessed(header.tvmCaller, amount);
    }
    
    event RequestProcessed(string indexed user, uint256 amount);
}
```

## Key Differences from Basic Contracts

### 1. Multiple Inheritance (Order Matters!)

```solidity
contract MyUpgradeableProxy is
    Initializable,           // Must be first
    OwnableUpgradeable,      // Access control
    UUPSUpgradeable,         // Upgrade mechanism  
    TacProxyV1Upgradeable    // TAC functionality (last)
```

The inheritance order is critical and must follow OpenZeppelin's recommended pattern.

### 2. Constructor vs Initialize

```solidity
// ❌ DON'T use constructor for setup
constructor(address crossChainLayer) {
    // This won't work properly with upgradeable contracts!
}

// ✅ DO use initializer function
function initialize(address owner, address crossChainLayer) 
    public 
    initializer 
{
    __UUPSUpgradeable_init();
    __Ownable_init(owner);
    __TacProxyV1Upgradeable_init(crossChainLayer);
}
```

### 3. Constructor Disabling

```solidity
/// @custom:oz-upgrades-unsafe-allow constructor
constructor() {
    _disableInitializers(); // Prevents initialization of implementation
}
```

This prevents the implementation contract from being initialized, which could be a security risk.

### 4. Upgrade Authorization

```solidity
function _authorizeUpgrade(address newImplementation) 
    internal 
    override 
    onlyOwner 
{}
```

This function controls who can upgrade the contract. Only the owner can upgrade in this example.

## Complete Real-World Example

Here's a practical upgradeable proxy for a lending protocol:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.28;

import { Initializable } from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import { UUPSUpgradeable } from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";
import { OwnableUpgradeable } from "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
import { IERC20Upgradeable } from "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol";
import { TacProxyV1Upgradeable } from "@tonappchain/evm-ccl/contracts/proxies/TacProxyV1Upgradeable.sol";
import { TokenAmount, OutMessageV1, TacHeaderV1 } from "@tonappchain/evm-ccl/contracts/core/Structs.sol";

interface ILendingProtocol {
    function supply(address asset, uint256 amount) external;
    function borrow(address asset, uint256 amount) external;
    function withdraw(address asset, uint256 amount) external;
    function repay(address asset, uint256 amount) external;
}

contract LendingProxy is
    Initializable,
    OwnableUpgradeable,
    UUPSUpgradeable,
    TacProxyV1Upgradeable
{
    ILendingProtocol public lendingProtocol;
    mapping(string => bool) public authorizedUsers; // V2 addition
    uint256 public minAmount; // V2 addition
    
    struct SupplyParams {
        address token;
        uint256 amount;
    }
    
    struct BorrowParams {
        address collateralToken;
        uint256 collateralAmount;
        address borrowToken;
        uint256 borrowAmount;
    }
    
    event LendingOperation(
        string indexed user,
        string operation,
        address token,
        uint256 amount
    );

    /// @custom:oz-upgrades-unsafe-allow constructor
    constructor() {
        _disableInitializers();
    }

    function initialize(
        address owner,
        address crossChainLayer,
        address _lendingProtocol
    ) public initializer {
        __UUPSUpgradeable_init();
        __Ownable_init(owner);
        __TacProxyV1Upgradeable_init(crossChainLayer);
        
        lendingProtocol = ILendingProtocol(_lendingProtocol);
        minAmount = 1e18; // 1 token minimum
    }

    function _authorizeUpgrade(address newImplementation) 
        internal 
        override 
        onlyOwner 
    {}

    // V1 Function: Basic supply
    function supply(bytes calldata tacHeader, bytes calldata arguments)
        external
        _onlyCrossChainLayer
    {
        TacHeaderV1 memory header = _decodeTacHeader(tacHeader);
        SupplyParams memory params = abi.decode(arguments, (SupplyParams));
        
        // V2 validation (added in upgrade)
        require(params.amount >= minAmount, "Amount below minimum");
        
        // Supply collateral to lending protocol
        IERC20Upgradeable(params.token).approve(
            address(lendingProtocol), 
            params.amount
        );
        lendingProtocol.supply(params.token, params.amount);
        
        emit LendingOperation(
            header.tvmCaller, 
            "SUPPLY", 
            params.token, 
            params.amount
        );
    }

    // V1 Function: Supply and borrow in one transaction
    function supplyAndBorrow(bytes calldata tacHeader, bytes calldata arguments)
        external
        _onlyCrossChainLayer
    {
        TacHeaderV1 memory header = _decodeTacHeader(tacHeader);
        BorrowParams memory params = abi.decode(arguments, (BorrowParams));
        
        // V2 authorization check (added in upgrade)
        require(authorizedUsers[header.tvmCaller], "User not authorized");
        
        // Supply collateral
        IERC20Upgradeable(params.collateralToken).approve(
            address(lendingProtocol), 
            params.collateralAmount
        );
        lendingProtocol.supply(params.collateralToken, params.collateralAmount);
        
        // Borrow tokens
        lendingProtocol.borrow(params.borrowToken, params.borrowAmount);
        
        // Send borrowed tokens back to TON user
        sendTokensBack(header, params.borrowToken, params.borrowAmount);
        
        emit LendingOperation(
            header.tvmCaller, 
            "SUPPLY_AND_BORROW", 
            params.borrowToken, 
            params.borrowAmount
        );
    }
    
    // V2 Function: Added in upgrade
    function authorizeUser(string memory tonUser) external onlyOwner {
        authorizedUsers[tonUser] = true;
    }
    
    // V2 Function: Added in upgrade  
    function setMinAmount(uint256 _minAmount) external onlyOwner {
        minAmount = _minAmount;
    }

    function sendTokensBack(
        TacHeaderV1 memory header,
        address token,
        uint256 amount
    ) internal {
        TokenAmount[] memory tokensToSend = new TokenAmount[](1);
        tokensToSend[0] = TokenAmount(token, amount);
        
        IERC20Upgradeable(token).approve(_getCrossChainLayerAddress(), amount);
        
        OutMessageV1 memory outMsg = OutMessageV1({
            shardsKey: header.shardsKey,
            tvmTarget: header.tvmCaller,
            tvmPayload: "",
            tvmProtocolFee: 0,
            tvmExecutorFee: 0,
            tvmValidExecutors: new string[](0),
            toBridge: tokensToSend,
            toBridgeNFT: new NFTAmount[](0)
        });
        
        _sendMessageV1(outMsg, 0);
    }

    /**
     * @dev Storage gap for future upgrades
     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps
     */
    uint256[48] private __gap;
}
```

## Storage Considerations

### Storage Gaps

Always include storage gaps to allow adding new state variables in future upgrades:

```solidity
contract MyProxy is /* ... */ {
    // Your state variables
    mapping(string => uint256) public userBalances;
    uint256 public totalProcessed;
    
    // Reserve space for future variables
    uint256[48] private __gap; // 50 slots - 2 used = 48 remaining
}
```

### Safe Storage Practices

```solidity
// ✅ SAFE: Adding new variables at the end
contract V1 {
    uint256 public totalSupply;
    mapping(address => uint256) public balances;
    uint256[48] private __gap;
}

contract V2 {
    uint256 public totalSupply;          // Same position
    mapping(address => uint256) public balances; // Same position
    uint256 public newFeature;           // New variable at end
    uint256[47] private __gap;           // Reduced gap
}

// ❌ DANGEROUS: Changing existing variable order
contract V2Bad {
    uint256 public newFeature;           // DON'T DO THIS
    uint256 public totalSupply;          // This moves storage slots!
    mapping(address => uint256) public balances;
}
```

## Deployment and Upgrades

### Initial Deployment

```javascript
// scripts/deploy-upgradeable.js
const { ethers, upgrades } = require("hardhat");

async function main() {
  const [deployer] = await ethers.getSigners();
  
  const crossChainLayerAddress = process.env.CROSS_CHAIN_LAYER_ADDRESS;
  const lendingProtocolAddress = "0x..."; // Your lending protocol
  
  console.log("Deploying upgradeable proxy...");
  
  const LendingProxy = await ethers.getContractFactory("LendingProxy");
  
  const proxy = await upgrades.deployProxy(LendingProxy, [
    deployer.address,        // owner
    crossChainLayerAddress,  // TAC CrossChainLayer
    lendingProtocolAddress   // lending protocol
  ], {
    initializer: 'initialize',
    kind: 'uups',
  });
  
  await proxy.deployed();
  
  console.log("Proxy deployed to:", proxy.address);
  console.log("Implementation deployed to:", 
    await upgrades.erc1967.getImplementationAddress(proxy.address)
  );
  
  // Save deployment info
  const deploymentInfo = {
    proxy: proxy.address,
    implementation: await upgrades.erc1967.getImplementationAddress(proxy.address),
    deployer: deployer.address,
    network: network.name,
    timestamp: new Date().toISOString()
  };
  
  console.log("Deployment info:", deploymentInfo);
}
```

### Upgrading the Contract

```javascript
// scripts/upgrade-contract.js
const { ethers, upgrades } = require("hardhat");

async function main() {
  const proxyAddress = "0x..."; // Your proxy address from initial deployment
  
  console.log("Upgrading contract at:", proxyAddress);
  
  const LendingProxyV2 = await ethers.getContractFactory("LendingProxy");
  
  // This validates the upgrade is safe
  await upgrades.validateUpgrade(proxyAddress, LendingProxyV2);
  
  // Perform the upgrade
  const upgraded = await upgrades.upgradeProxy(proxyAddress, LendingProxyV2);
  
  console.log("Contract upgraded successfully");
  console.log("New implementation:", 
    await upgrades.erc1967.getImplementationAddress(proxyAddress)
  );
  
  // Test the upgrade worked
  const contract = await ethers.getContractAt("LendingProxy", proxyAddress);
  console.log("Min amount (new in V2):", await contract.minAmount());
}
```

## Upgrade Safety

### Validating Upgrades

Always validate upgrades before deploying:

```bash
# Check if upgrade is safe
npx hardhat run scripts/validate-upgrade.js
```

```javascript
// scripts/validate-upgrade.js
const { upgrades } = require("hardhat");

async function main() {
  const proxyAddress = "0x...";
  const LendingProxyV2 = await ethers.getContractFactory("LendingProxyV2");
  
  try {
    await upgrades.validateUpgrade(proxyAddress, LendingProxyV2);
    console.log("✅ Upgrade is safe");
  } catch (error) {
    console.error("❌ Upgrade validation failed:", error.message);
    process.exit(1);
  }
}
```

### Upgrade Checklist

<AccordionGroup>
  <Accordion title="Pre-Upgrade Validation" icon="check-circle">
    
    ✅ Run `upgrades.validateUpgrade()` to check compatibility
    ✅ Review storage layout changes
    ✅ Test upgrade on testnet first
    ✅ Verify all existing functions still work
    ✅ Check that new functions work correctly
    
  </Accordion>
  
  <Accordion title="During Upgrade" icon="settings">
    
    ✅ Announce upgrade to users in advance  
    ✅ Consider pausing contract during upgrade
    ✅ Monitor for any failed transactions
    ✅ Have rollback plan ready
    
  </Accordion>
  
  <Accordion title="Post-Upgrade" icon="eye">
    
    ✅ Verify upgrade completed successfully
    ✅ Test critical functions
    ✅ Monitor contract behavior
    ✅ Update documentation and interfaces
    
  </Accordion>
</AccordionGroup>

## Testing Upgrades

```solidity
// test/LendingProxy.upgrade.test.js
const { expect } = require("chai");
const { ethers, upgrades } = require("hardhat");

describe("LendingProxy Upgrades", function () {
  let proxy, owner, user;
  
  beforeEach(async function() {
    [owner, user] = await ethers.getSigners();
    
    // Deploy V1
    const LendingProxyV1 = await ethers.getContractFactory("LendingProxy");
    proxy = await upgrades.deployProxy(LendingProxyV1, [
      owner.address,
      mockCrossChainLayer.address,
      mockLendingProtocol.address
    ]);
  });
  
  it("should upgrade while preserving state", async function() {
    // Use V1 to set some state
    await proxy.connect(mockCrossChainLayer).supply(mockHeader, mockArgs);
    const balanceBefore = await proxy.userBalances("EQUser123");
    
    // Upgrade to V2
    const LendingProxyV2 = await ethers.getContractFactory("LendingProxy");
    const upgradedProxy = await upgrades.upgradeProxy(proxy.address, LendingProxyV2);
    
    // Verify state was preserved
    const balanceAfter = await upgradedProxy.userBalances("EQUser123");
    expect(balanceAfter).to.equal(balanceBefore);
    
    // Verify new functionality works
    await upgradedProxy.authorizeUser("EQUser123");
    expect(await upgradedProxy.authorizedUsers("EQUser123")).to.be.true;
  });
  
  it("should prevent unauthorized upgrades", async function() {
    const LendingProxyV2 = await ethers.getContractFactory("LendingProxy");
    
    await expect(
      upgrades.upgradeProxy(proxy.address, LendingProxyV2.connect(user))
    ).to.be.revertedWith("Ownable: caller is not the owner");
  });
});
```

## When NOT to Upgrade

Sometimes it's better to deploy a new contract:

**Deploy new contract when:**
- Fundamental architecture changes needed  
- Storage layout conflicts can't be resolved
- Business model changes significantly
- Security model needs complete overhaul

**Migration strategy:**
```solidity
contract ProxyV1 {
    address public migrationTarget;
    bool public migrationEnabled;
    
    function enableMigration(address newContract) external onlyOwner {
        migrationTarget = newContract;
        migrationEnabled = true;
    }
    
    function migrate(bytes calldata tacHeader, bytes calldata arguments)
        external
        _onlyCrossChainLayer
    {
        require(migrationEnabled, "Migration not enabled");
        
        // Forward call to new contract
        INewProxy(migrationTarget).processRequest(tacHeader, arguments);
    }
}
```

## What's Next?

You now understand both basic and upgradeable proxy patterns. Choose the right approach for your needs:

<CardGroup cols={2}>
  <Card
    title="Message Flow Deep Dive"
    icon="arrow-left-right"
    href="/build/proxy/usage/message-flow"
  >
    Understand exactly how cross-chain messages work
  </Card>
  <Card
    title="Advanced Patterns"
    icon="rocket"
    href="/build/proxy/advanced-usage/argument-encoding"
  >
    Explore complex proxy implementation strategies
  </Card>
</CardGroup>

<Warning>
  **Remember**: Start with basic contracts. Only add upgradeability when you have a specific, concrete reason that justifies the added complexity.
</Warning>