    ---
    title: Implementing Proxy Functions
    description: "Build the core logic that processes cross-chain calls and arguments"
    ---

    Proxy functions are the heart of your TAC contracts - they receive cross-chain calls from TON users and execute your application logic. This guide covers how to implement robust proxy functions that handle different use cases and error conditions.

    ## Function Signature Requirements

    Every proxy function that handles cross-chain calls must follow this exact pattern:

    ```solidity
    function yourFunctionName(bytes calldata tacHeader, bytes calldata arguments)
        external
        _onlyCrossChainLayer
    {
        // Your implementation
    }
    ```

    **Required Components:**
    - `bytes calldata tacHeader` - Contains verified TON user information
    - `bytes calldata arguments` - Your custom encoded parameters
    - `external` visibility - Functions must be externally callable
    - `_onlyCrossChainLayer` modifier - Security requirement

    ## Basic Function Structure

    ### Template Pattern

    ```solidity
    function processRequest(bytes calldata tacHeader, bytes calldata arguments)
        external
        _onlyCrossChainLayer
    {
        // 1. Decode the TAC header
        TacHeaderV1 memory header = _decodeTacHeader(tacHeader);

        // 2. Decode your custom arguments
        YourParamsStruct memory params = abi.decode(arguments, (YourParamsStruct));

        // 3. Validate inputs
        require(params.amount > 0, "Amount must be positive");
        require(params.deadline > block.timestamp, "Request expired");

        // 4. Execute your business logic
        ProcessingResult memory result = executeBusinessLogic(params);

        // 5. Handle response (if needed)
        if (shouldSendResponse(result)) {
            sendResponseToTON(header, result);
        }

        // 6. Emit events for tracking
        emit RequestProcessed(header.tvmCaller, header.operationId, result);
    }
    ```

    ## Parameter Encoding and Decoding

    ### Simple Parameters

    For basic data types, use straightforward encoding:

    ```solidity
    struct SimpleParams {
        address token;
        uint256 amount;
        address recipient;
    }

    function handleSimpleParams(bytes calldata tacHeader, bytes calldata arguments)
        external
        _onlyCrossChainLayer
    {
        // Decode parameters
        SimpleParams memory params = abi.decode(arguments, (SimpleParams));

        // Use the parameters
        IERC20(params.token).transfer(params.recipient, params.amount);
    }
    ```

    ### Complex Parameters

    For complex data with arrays or nested structures:

    ```solidity
    struct ComplexParams {
        address[] tokens;
        uint256[] amounts;
        bytes swapData;
        uint256 deadline;
    }

    function handleComplexParams(bytes calldata tacHeader, bytes calldata arguments)
        external
        _onlyCrossChainLayer
    {
        ComplexParams memory params = abi.decode(arguments, (ComplexParams));

        // Validate array lengths match
        require(params.tokens.length == params.amounts.length, "Array length mismatch");

        // Process each token
        for (uint i = 0; i < params.tokens.length; i++) {
            processToken(params.tokens[i], params.amounts[i]);
        }

        // Use additional data
        if (params.swapData.length > 0) {
            executeSwap(params.swapData);
        }
    }
    ```

    ### Multiple Encoding Patterns

    Sometimes you need different parameter structures for the same function:

    ```solidity
    enum OperationType { SWAP, LEND, BORROW }

    struct UnifiedParams {
        OperationType opType;
        bytes specificData;
    }

    function handleMultipleTypes(bytes calldata tacHeader, bytes calldata arguments)
        external
        _onlyCrossChainLayer
    {
        UnifiedParams memory params = abi.decode(arguments, (UnifiedParams));

        if (params.opType == OperationType.SWAP) {
            SwapParams memory swapParams = abi.decode(params.specificData, (SwapParams));
            executeSwap(swapParams);
        } else if (params.opType == OperationType.LEND) {
            LendParams memory lendParams = abi.decode(params.specificData, (LendParams));
            executeLend(lendParams);
        } else {
            BorrowParams memory borrowParams = abi.decode(params.specificData, (BorrowParams));
            executeBorrow(borrowParams);
        }
    }
    ```

    ## Complete Implementation Walkthrough

    Let's build a complete proxy function step-by-step, showing external Dapp integration - the most common real-world pattern:

    ```solidity
    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.28;

    import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
    import { TacProxyV1 } from "@tonappchain/evm-ccl/contracts/proxies/TacProxyV1.sol";
    import { TokenAmount, OutMessageV1, TacHeaderV1 } from "@tonappchain/evm-ccl/contracts/core/Structs.sol";

    interface IDappContract {
        function doSomething(address tokenFrom, address tokenTo, uint256 amount)
            external returns (uint256);
    }

    contract MyProxy is TacProxyV1 {
        IDappContract public dappContract;

        struct MyProxyFunctionArguments {
            address tokenFrom;
            address tokenTo;
            uint256 amount;
        }

        constructor(address _dappContract, address _crossChainLayer)
            TacProxyV1(_crossChainLayer)
        {
            dappContract = IDappContract(_dappContract);
        }

        function myProxyFunction(bytes calldata tacHeader, bytes calldata arguments)
            external
            _onlyCrossChainLayer
        {
            // 1. Decode the custom arguments
            MyProxyFunctionArguments memory args = abi.decode(arguments, (MyProxyFunctionArguments));

            // 2. Approve tokens to your Dapp contract for some action
            IERC20(args.tokenFrom).approve(address(dappContract), args.amount);

            // 3. Call the Dapp contract
            uint256 tokenToAmount = dappContract.doSomething(
                args.tokenFrom,
                args.tokenTo,
                args.amount
            );

            // 4. Prepare tokens to send back to TON
            TokenAmount[] memory tokensToBridge = new TokenAmount[](1);
            tokensToBridge[0] = TokenAmount(args.tokenTo, tokenToAmount);

            // 5. Approve the CrossChainLayer to pull them
            IERC20(tokensToBridge[0].evmAddress).approve(
                _getCrossChainLayerAddress(),
                tokensToBridge[0].amount
            );

            // 6. Decode the TAC header
            TacHeaderV1 memory header = _decodeTacHeader(tacHeader);

            // 7. Form an OutMessage
            OutMessageV1 memory outMsg = OutMessageV1({
                shardsKey: header.shardsKey,           // Use same key for RoundTrip
                tvmTarget: header.tvmCaller,           // Send back to caller
                tvmPayload: "",                        // Must be empty - not supported
                tvmProtocolFee: 0,                     // 0 for RoundTrip - already paid on TON
                tvmExecutorFee: 0,                     // 0 for RoundTrip - already paid on TON
                tvmValidExecutors: new string[](0),    // Empty for RoundTrip - already defined on TON
                toBridge: tokensToBridge,              // Result tokens
                toBridgeNFT: new NFTAmount[](0)        // No NFTs
            });

            // 8. Send message back through CrossChainLayer with zero native
            _sendMessageV1(outMsg, 0);
        }
    }
    ```

    **This example shows the complete flow:**
    - External Dapp contract integration (lines 11-13, 19-21, 32-38)
    - Token approval for external contracts (line 33)
    - Processing and getting results (lines 35-38)
    - RoundTrip response pattern (lines 48-58)
    - Proper fee handling for RoundTrip messages (lines 52-53)

    ## Business Logic Implementation

    ### DeFi Integration Example

    ```solidity
    interface IUniswapRouter {
        function swapExactTokensForTokens(
            uint amountIn,
            uint amountOutMin,
            address[] calldata path,
            address to,
            uint deadline
        ) external returns (uint[] memory amounts);
    }

    contract DeFiProxy is TacProxyV1 {
        IUniswapRouter public immutable router;

        struct SwapParams {
            address tokenIn;
            address tokenOut;
            uint256 amountIn;
            uint256 amountOutMin;
            uint256 deadline;
        }

        constructor(address _crossChainLayer, address _router)
            TacProxyV1(_crossChainLayer)
        {
            router = IUniswapRouter(_router);
        }

        function executeSwap(bytes calldata tacHeader, bytes calldata arguments)
            external
            _onlyCrossChainLayer
        {
            TacHeaderV1 memory header = _decodeTacHeader(tacHeader);
            SwapParams memory params = abi.decode(arguments, (SwapParams));

            // Validate parameters
            require(params.amountIn > 0, "Invalid amount");
            require(params.deadline > block.timestamp, "Expired");
            require(params.tokenIn != params.tokenOut, "Same token");

            // Check token balance (tokens are already in contract)
            uint256 balance = IERC20(params.tokenIn).balanceOf(address(this));
            require(balance >= params.amountIn, "Insufficient balance");

            // Approve router to spend tokens
            IERC20(params.tokenIn).approve(address(router), params.amountIn);

            // Build swap path
            address[] memory path = new address[](2);
            path[0] = params.tokenIn;
            path[1] = params.tokenOut;

            // Execute swap
            uint[] memory amounts = router.swapExactTokensForTokens(
                params.amountIn,
                params.amountOutMin,
                path,
                address(this),
                params.deadline
            );

            // Send result back to TON user
            sendSwapResult(header, params.tokenOut, amounts[1]);

            emit SwapExecuted(
                header.tvmCaller,
                params.tokenIn,
                params.tokenOut,
                params.amountIn,
                amounts[1]
            );
        }

        function sendSwapResult(TacHeaderV1 memory header, address token, uint256 amount)
            internal
        {
            TokenAmount[] memory tokensToSend = new TokenAmount[](1);
            tokensToSend[0] = TokenAmount(token, amount);

            IERC20(token).approve(_getCrossChainLayerAddress(), amount);

            OutMessageV1 memory outMsg = OutMessageV1({
                shardsKey: header.shardsKey,
                tvmTarget: header.tvmCaller,
                tvmPayload: "",                     // Must be empty - not supported
                tvmProtocolFee: 0,                  // 0 for RoundTrip - already paid on TON
                tvmExecutorFee: 0,                  // 0 for RoundTrip - already paid on TON
                tvmValidExecutors: new string[](0), // Empty for RoundTrip - already defined on TON
                toBridge: tokensToSend,
                toBridgeNFT: new NFTAmount[](0)
            });

            _sendMessageV1(outMsg, 0);
        }
    }
    ```

    ### NFT Handling Example

    ```solidity
    import { IERC721 } from "@openzeppelin/contracts/token/ERC721/IERC721.sol";
    import { IERC721Receiver } from "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol";

    contract NFTProxy is TacProxyV1, IERC721Receiver {
        struct MintParams {
            address nftContract;
            uint256 price;
            string metadataURI;
        }

        event NFTMinted(address indexed user, address nftContract, uint256 tokenId);

        function onERC721Received(address, address, uint256, bytes calldata)
            external
            pure
            override
            returns (bytes4)
        {
            return this.onERC721Received.selector;
        }

        function mintNFT(bytes calldata tacHeader, bytes calldata arguments)
            external
            _onlyCrossChainLayer
        {
            TacHeaderV1 memory header = _decodeTacHeader(tacHeader);
            MintParams memory params = abi.decode(arguments, (MintParams));

            // Validate NFT contract
            require(isValidNFTContract(params.nftContract), "Invalid NFT contract");

            // Check payment (assuming USDT payment)
            address paymentToken = getPaymentToken();
            uint256 balance = IERC20(paymentToken).balanceOf(address(this));
            require(balance >= params.price, "Insufficient payment");

            // Transfer payment to contract owner or treasury
            IERC20(paymentToken).transfer(owner(), params.price);

            // Mint NFT to this contract first
            uint256 tokenId = ICustomNFT(params.nftContract).mint(
                address(this),
                params.metadataURI
            );

            // Send NFT back to TON user
            sendNFTToTON(header, params.nftContract, tokenId);

            emit NFTMinted(header.tvmCaller, params.nftContract, tokenId);
        }

        function sendNFTToTON(TacHeaderV1 memory header, address nftContract, uint256 tokenId)
            internal
        {
            // Approve CrossChainLayer to transfer NFT
            IERC721(nftContract).approve(_getCrossChainLayerAddress(), tokenId);

            // Prepare NFT for bridging
            NFTAmount[] memory nftsToSend = new NFTAmount[](1);
            nftsToSend[0] = NFTAmount(nftContract, tokenId);

            OutMessageV1 memory outMsg = OutMessageV1({
                shardsKey: header.shardsKey,
                tvmTarget: header.tvmCaller,
                tvmPayload: "",                     // Must be empty - not supported
                tvmProtocolFee: 0,                  // 0 for RoundTrip - already paid on TON
                tvmExecutorFee: 0,                  // 0 for RoundTrip - already paid on TON
                tvmValidExecutors: new string[](0), // Empty for RoundTrip - already defined on TON
                toBridge: new TokenAmount[](0),
                toBridgeNFT: nftsToSend
            });

            _sendMessageV1(outMsg, 0);
        }
    }
    ```

    ## Error Handling and Validation

    ### Input Validation

    ```solidity
    function validateAndProcess(bytes calldata tacHeader, bytes calldata arguments)
        external
        _onlyCrossChainLayer
    {
        TacHeaderV1 memory header = _decodeTacHeader(tacHeader);
        ProcessParams memory params = abi.decode(arguments, (ProcessParams));

        // Validate header data
        require(bytes(header.tvmCaller).length > 0, "Invalid caller");
        require(header.timestamp <= block.timestamp, "Future timestamp");
        require(header.timestamp > block.timestamp - 3600, "Request too old");

        // Validate parameters
        require(params.amount > 0 && params.amount <= MAX_AMOUNT, "Invalid amount");
        require(params.recipient != address(0), "Zero address recipient");
        require(isValidToken(params.token), "Unsupported token");

        // Additional business logic validation
        require(checkUserPermissions(header.tvmCaller), "Unauthorized user");
        require(checkRateLimit(header.tvmCaller), "Rate limit exceeded");

        // Execute if all validations pass
        processValidatedRequest(header, params);
    }
    ```

    ### Try-Catch Error Handling

    ```solidity
    function robustProcessing(bytes calldata tacHeader, bytes calldata arguments)
        external
        _onlyCrossChainLayer
    {
        TacHeaderV1 memory header = _decodeTacHeader(tacHeader);

        try this.executeRiskyOperation(arguments) returns (ProcessingResult memory result) {
            // Success case
            handleSuccess(header, result);
        } catch Error(string memory reason) {
            // Handle expected errors
            handleExpectedError(header, reason);
        } catch Panic(uint errorCode) {
            // Handle panic errors (overflow, division by zero, etc.)
            handlePanicError(header, errorCode);
        } catch (bytes memory lowLevelData) {
            // Handle unexpected low-level errors
            handleUnexpectedError(header, lowLevelData);
        }
    }

    function executeRiskyOperation(bytes calldata arguments)
        external
        returns (ProcessingResult memory)
    {
        require(msg.sender == address(this), "Internal only");

        // Risky operations that might fail
        RiskyParams memory params = abi.decode(arguments, (RiskyParams));

        // This might revert
        uint256 result = performComplexCalculation(params.input);

        return ProcessingResult(result, true);
    }
    ```

    ### Graceful Fallbacks

    ```solidity
    function processWithFallback(bytes calldata tacHeader, bytes calldata arguments)
        external
        _onlyCrossChainLayer
    {
        TacHeaderV1 memory header = _decodeTacHeader(tacHeader);
        RequestParams memory params = abi.decode(arguments, (RequestParams));

        bool success = false;
        ProcessingResult memory result;

        // Try primary method
        try this.primaryProcessing(params) returns (ProcessingResult memory primaryResult) {
            result = primaryResult;
            success = true;
        } catch {
            // Try fallback method
            try this.fallbackProcessing(params) returns (ProcessingResult memory fallbackResult) {
                result = fallbackResult;
                success = true;
                emit FallbackUsed(header.operationId);
            } catch {
                // Both failed, send error response
                success = false;
            }
        }

        if (success) {
            sendSuccessResponse(header, result);
        } else {
            sendErrorResponse(header, "Processing failed");
        }
    }
    ```

    ## State Management

    ### User State Tracking

    ```solidity
    contract StatefulProxy is TacProxyV1 {
        struct UserState {
            uint256 totalProcessed;
            uint256 lastOperationTime;
            bool isActive;
            mapping(address => uint256) tokenBalances;
        }

        mapping(string => UserState) public userStates; // TON address -> state

        function updateUserState(bytes calldata tacHeader, bytes calldata arguments)
            external
            _onlyCrossChainLayer
        {
            TacHeaderV1 memory header = _decodeTacHeader(tacHeader);
            StateUpdateParams memory params = abi.decode(arguments, (StateUpdateParams));

            UserState storage userState = userStates[header.tvmCaller];

            // Update user statistics
            userState.totalProcessed += params.amount;
            userState.lastOperationTime = block.timestamp;

            // Update token balances
            userState.tokenBalances[params.token] += params.amount;

            // Check if user should be marked active
            if (!userState.isActive && userState.totalProcessed > ACTIVATION_THRESHOLD) {
                userState.isActive = true;
                emit UserActivated(header.tvmCaller);
            }

            emit StateUpdated(header.tvmCaller, params.amount, block.timestamp);
        }
    }
    ```

    ### Cross-Function State Consistency

    ```solidity
    contract ConsistentProxy is TacProxyV1 {
        mapping(bytes32 => bool) public processedOperations;
        uint256 public totalVolume;

        modifier nonReentrant(bytes32 operationId) {
            require(!processedOperations[operationId], "Operation already processed");
            processedOperations[operationId] = true;
            _;
        }

        function processA(bytes calldata tacHeader, bytes calldata arguments)
            external
            _onlyCrossChainLayer
            nonReentrant(keccak256(abi.encodePacked(tacHeader, arguments)))
        {
            TacHeaderV1 memory header = _decodeTacHeader(tacHeader);

            // Process with state updates
            uint256 amount = abi.decode(arguments, (uint256));
            totalVolume += amount;

            // Execute operation A
            executeOperationA(amount);

            emit OperationACompleted(header.tvmCaller, amount, totalVolume);
        }

        function processB(bytes calldata tacHeader, bytes calldata arguments)
            external
            _onlyCrossChainLayer
            nonReentrant(keccak256(abi.encodePacked(tacHeader, arguments)))
        {
            TacHeaderV1 memory header = _decodeTacHeader(tacHeader);

            // Process with state updates
            uint256 amount = abi.decode(arguments, (uint256));
            totalVolume += amount;

            // Execute operation B
            executeOperationB(amount);

            emit OperationBCompleted(header.tvmCaller, amount, totalVolume);
        }
    }
    ```

    ## Testing Proxy Functions

    ### Unit Test Example

    ```solidity
    contract ProxyFunctionTest is Test {
        MyProxy proxy;
        MockCrossChainLayer crossChainLayer;
        TestToken testToken;

        function setUp() public {
            crossChainLayer = new MockCrossChainLayer();
            testToken = new TestToken();
            proxy = new MyProxy(address(crossChainLayer));
        }

        function testSuccessfulProcessing() public {
            // Prepare test data
            TacHeaderV1 memory header = TacHeaderV1({
                shardsKey: 1,
                timestamp: block.timestamp,
                operationId: keccak256("test-op"),
                tvmCaller: "EQTestUser123...",
                extraData: ""
            });

            ProcessParams memory params = ProcessParams({
                token: address(testToken),
                amount: 1000e18,
                recipient: address(0x123)
            });

            bytes memory encodedHeader = abi.encode(header);
            bytes memory encodedParams = abi.encode(params);

            // Fund the proxy with tokens
            testToken.transfer(address(proxy), 1000e18);

            // Set up cross chain layer to call proxy
            crossChainLayer.setProxyCall(
                address(proxy),
                "processRequest(bytes,bytes)",
                encodedHeader,
                encodedParams
            );

            // Execute
            vm.expectEmit(true, true, false, true);
            emit RequestProcessed(header.tvmCaller, header.operationId, /* expected result */);

            crossChainLayer.executeProxyCall();

            // Verify results
            assertEq(testToken.balanceOf(address(0x123)), 1000e18);
        }
    }
    ```

    ## What's Next?

    Now that you understand how to implement proxy functions, learn about managing fees:

    <CardGroup cols={2}>
    <Card
        title="Fee Management"
        icon="dollar-sign"
        href="/build/proxy/usage/fee-management"
    >
        Understand how to handle protocol fees and executor payments
    </Card>
    <Card
        title="Advanced Usage"
        icon="rocket"
        href="/build/proxy/advanced-usage/argument-encoding"
    >
        Explore advanced patterns for complex proxy implementations
    </Card>
    </CardGroup>
